# API-001 Implementation Progress

## 2026-02-03: US-001 - ShoppingListItem JSON:API Implementation

### What was implemented:
- Added AshJsonApi.Resource extension to ShoppingListItem resource
- Created nested routes under `/api/json/shopping_lists/:shopping_list_id/items`
- Implemented endpoints: GET (index), GET (show), POST (create), PATCH (update), DELETE (destroy)
- Added custom action routes: `/check`, `/uncheck`, `/toggle`
- Created `create_from_api` action that derives `account_id` from parent shopping list

### Key learnings:

1. **AshJsonApi nested routes**: Use `base "/parent/:parent_id/children"` pattern for DDD aggregate roots. The `derive_filter? true` option helps filter index results by route params.

2. **Action arguments from routes**: For nested POST routes, the parent ID from the URL is passed as an action argument. Use `argument :parent_id, :uuid` to capture it.

3. **Deriving attributes from parent**: When creating a child resource, you can derive the tenant (`account_id`) from the parent by:
   - Fetching the parent via domain code interface: `Domain.get_parent(id, opts)`
   - Using `Ash.Changeset.change_attribute(:account_id, parent.account_id)`
   - NEVER use `Ash.get/read/write` directly - always go through domain code interfaces

4. **Context in Ash changes**: The context parameter in `change fn changeset, context -> ...` is an `Ash.Resource.Change.Context` struct, NOT a map. Access fields via struct syntax `context.tenant`, not `context[:tenant]`.

5. **Relationship vs attribute management**: Use `manage_relationship/4` for actual relationships (belongs_to/has_many), use `change_attribute/3` for attribute fields like `account_id`.

6. **JSON:API PATCH requests**: All PATCH requests in JSON:API require a `data` payload with `type` and `id`, even for custom actions that don't accept any attributes.

7. **Multitenancy isolation**: Tenant-isolated resources return empty results (not 403) when accessing data outside the user's tenant. This is the expected behavior for attribute-based multitenancy.

8. **Test patterns for JSON:API**:
   - Use `put_req_header("accept", "application/vnd.api+json")`
   - Use `put_req_header("content-type", "application/vnd.api+json")` for POST/PATCH
   - JWT token via `Phoenix.Token.sign(Endpoint, "user auth", user.id)`
   - DELETE returns 200 with resource data by default in AshJsonApi

### Files changed:
- `lib/grocery_planner/shopping/shopping_list_item.ex` - Added AshJsonApi extension and create_from_api action
- `test/support/shopping_test_helpers.ex` - New test helpers for Shopping domain
- `test/grocery_planner_web/controllers/api/shopping_list_item_test.exs` - 14 behavioral API tests

### Next priorities (from API-001):
- US-003: InventoryEntry nested under GroceryItem
- US-006/US-007: MealPlan templates and voting endpoints

---

## 2026-02-03: US-002 - RecipeIngredient JSON:API Implementation

### What was implemented:
- Added AshJsonApi.Resource extension to RecipeIngredient resource
- Created nested routes under `/api/json/recipes/:recipe_id/ingredients`
- Implemented endpoints: GET (index), GET (show), POST (create), PATCH (update), DELETE (destroy)
- Created `create_from_api` action that derives `account_id` from parent recipe

### Key learnings:
1. **Pattern reuse**: The US-001 pattern for nested resources (ShoppingListItem) applied directly to RecipeIngredient with minimal changes
2. **grocery_item_id required**: RecipeIngredient requires a grocery_item_id association, unlike ShoppingListItem which has optional grocery_item linking
3. **Domain code interfaces**: Used `GroceryPlanner.Recipes.get_recipe/2` instead of direct Ash.get calls

### Files changed:
- `lib/grocery_planner/recipes/recipe_ingredient.ex` - Added AshJsonApi extension and create_from_api action
- `test/support/recipes_test_helpers.ex` - New test helpers for Recipes domain
- `test/grocery_planner_web/controllers/api/recipe_ingredient_test.exs` - 9 behavioral API tests

### Next priorities:
- US-006/US-007: MealPlan templates and voting endpoints

---

## 2026-02-03: US-003 - InventoryEntry Nested Routes Implementation

### What was implemented:
- Changed InventoryEntry from flat `/inventory_entries` to nested `/grocery_items/:grocery_item_id/inventory_entries`
- Implemented endpoints: GET (index), GET (show), POST (create), PATCH (update), DELETE (destroy)
- Created `list_by_grocery_item` read action with explicit filter for reliable filtering
- Created `create_from_api` action that derives `account_id` from parent grocery item

### Key learnings:

1. **derive_filter? unreliable**: The `derive_filter? true` option in AshJsonApi didn't filter by route params reliably. Solution: create a custom read action with explicit `filter expr(grocery_item_id == ^arg(:grocery_item_id))`.

2. **Create action policies**: Ash policies that use `relates_to_actor_via` fail for create actions with "Cannot use a filter to authorize a create" error. Solution: use `authorize_if always()` for create actions since the parent lookup already validates access.

3. **belongs_to public attribute**: For filtering to work on relationship foreign keys, the `belongs_to` must have `public? true`. Without this, filter attempts fail with "No such field" error.

4. **Duplicate attribute definitions**: Don't define both an explicit `attribute :foreign_key_id` AND a `belongs_to` relationship - the belongs_to creates the attribute automatically. Having both can cause confusion.

### Files changed:
- `lib/grocery_planner/inventory/inventory_entry.ex` - Changed routes to nested, added list_by_grocery_item and create_from_api actions, fixed policies
- `test/grocery_planner_web/controllers/api/inventory_entry_test.exs` - 11 behavioral API tests

---

## 2026-02-03: US-006 - MealPlanTemplate JSON:API Implementation

### What was implemented:
- Added AshJsonApi.Resource extension to MealPlanTemplate resource
- Created routes at `/api/json/meal_plan_templates` (not `/meal_plans/templates` to avoid route conflict)
- Implemented endpoints: GET (index), GET (show), POST (create), PATCH (update), DELETE (destroy)
- Added custom action routes: `/activate`, `/deactivate`
- Added AshJsonApi.Resource extension to MealPlanTemplateEntry resource
- Created nested routes under `/api/json/meal_plan_templates/:template_id/entries`
- Implemented endpoints: GET (index), GET (show), POST (create), PATCH (update), DELETE (destroy)
- Created `create_from_api` action that derives `account_id` from parent template
- Created `list_by_template` read action with explicit filter

### Key learnings:

1. **Route conflicts with nested paths**: Using `/meal_plans/templates` conflicts with existing `/meal_plans/:id` route because "templates" gets matched as an `:id` parameter. Solution: use a distinct base path like `/meal_plan_templates` instead.

2. **Top-level vs nested resource patterns**:
   - Top-level resources (MealPlanTemplate): Pass `account_id` in JSON attributes, use `set_attribute(:account_id, arg(:account_id))` in create action
   - Nested resources (MealPlanTemplateEntry): Use `create_from_api` action that fetches parent and derives `account_id` from it

3. **Consistent create policy pattern**: For API creates, use `authorize_if always()` and rely on:
   - Tenant isolation (set by ApiAuth plug)
   - Parent resource lookup validation (for nested resources)

4. **Code interface duplication**: Resources can define `code_interface` blocks while domain also has `define` statements. Both create callable functions - domain defines go on domain module, resource code_interface creates resource-level functions.

### Files changed:
- `lib/grocery_planner/meal_planning/meal_plan_template.ex` - Added AshJsonApi extension, routes, code_interface, updated create action
- `lib/grocery_planner/meal_planning/meal_plan_template_entry.ex` - Added AshJsonApi extension, routes, code_interface, create_from_api action
- `lib/grocery_planner/meal_planning.ex` - Added domain code interface definitions
- `test/support/meal_planning_test_helpers.ex` - Added template and entry helpers
- `test/grocery_planner_web/controllers/api/meal_plan_template_test.exs` - 13 behavioral tests
- `test/grocery_planner_web/controllers/api/meal_plan_template_entry_test.exs` - 11 behavioral tests

### Next priorities:
- US-004: Atomic Operations with Side Effects
- US-005: Consistent Error Responses
- US-008: Offline Sync Support

---

## 2026-02-03: US-007 - MealPlanVoteSession & MealPlanVoteEntry JSON:API Implementation

### What was implemented:
- Added AshJsonApi.Resource extension to MealPlanVoteSession resource
- Created routes at `/api/json/vote_sessions` (not `/meal_plans/vote_sessions` to avoid route conflict)
- Implemented endpoints: GET (index), GET (show), POST (create), PATCH (update), DELETE (destroy)
- Added custom action route: `PATCH /vote_sessions/:id/close`
- Added AshJsonApi.Resource extension to MealPlanVoteEntry resource
- Created nested routes under `/api/json/vote_sessions/:vote_session_id/entries`
- Implemented endpoints: GET (index), GET (show), POST (create), DELETE (destroy)
- Created `create_from_api` actions for both resources

### Key learnings:

1. **Bypassing multitenancy for parent derivation**: When a child resource needs to derive its `account_id` from a parent, and the parent uses attribute-based multitenancy, direct Ash queries fail because there's no tenant context yet. Solution: use `Repo.get/2` directly to bypass Ash's multitenancy layer for the initial lookup:
   ```elixir
   case GroceryPlanner.Repo.get(ParentResource, parent_id) do
     nil -> add_error(...)
     parent -> change_attribute(:account_id, parent.account_id)
   end
   ```

2. **Setting user from actor in API actions**: For actions where the user should be derived from the authenticated actor (like voting), use a simple change module:
   ```elixir
   defmodule SetUserFromActor do
     use Ash.Resource.Change
     def change(changeset, _opts, context) do
       case context.actor do
         %{id: user_id} -> change_attribute(changeset, :user_id, user_id)
         _ -> add_error(changeset, ...)
       end
     end
   end
   ```

3. **Nil-safe validation changes**: When validation changes run before all attributes are set (e.g., checking uniqueness before `account_id` is derived), guard with nil checks:
   ```elixir
   if is_nil(account_id) or is_nil(other_field) do
     changeset  # Skip check, validation will catch missing required fields
   else
     # Perform validation
   end
   ```

4. **Multiple change modules for API creates**: Complex API create actions often need multiple change modules in order:
   - `DeriveFromSession` - Get tenant from parent
   - `SetUserFromActor` - Get user from auth context
   - `EnsureSessionOpenForApi` - Business validation
   - `EnsureUniqueVoteForApi` - Uniqueness validation

5. **Policy pattern for API creates**: Use `authorize_if actor_present()` for API create actions since:
   - Tenant isolation is handled by the `account_id` derivation from parent
   - Parent lookup validates access to the parent resource

### Files changed:
- `lib/grocery_planner/meal_planning/meal_plan_vote_session.ex` - Added AshJsonApi extension, routes, create_from_api action
- `lib/grocery_planner/meal_planning/meal_plan_vote_entry.ex` - Added AshJsonApi extension, routes, create_from_api action with 4 new change modules
- `lib/grocery_planner/meal_planning.ex` - Added domain code interface definitions
- `test/support/meal_planning_test_helpers.ex` - Added vote session and entry helpers
- `test/grocery_planner_web/controllers/api/vote_session_test.exs` - 11 behavioral tests
- `test/grocery_planner_web/controllers/api/vote_entry_test.exs` - 12 behavioral tests

---

## 2026-02-03: US-004 - Atomic Operations with Side Effects

### What was implemented:
- Added JSON:API route for `generate_from_meal_plans` on ShoppingList resource
- Added JSON:API route for `complete` on MealPlan resource
- Created new `add_to_inventory` action on ShoppingListItem that transfers item data to InventoryEntry

### Key learnings:

1. **Exposing existing actions**: Many custom actions already exist in resources - just need to add JSON:API routes. Use `post :action_name, route: "/action_name"` for create-like actions, `patch :action_name, route: "/:id/action_name"` for update-like actions.

2. **Cross-domain operations**: When an action needs to create resources in another domain (ShoppingListItem â†’ InventoryEntry), use the target domain's code interface with proper tenant context:
   ```elixir
   GroceryPlanner.Inventory.create_inventory_entry(attrs, actor: context.actor, tenant: changeset.data.account_id)
   ```

3. **Action argument defaults**: Use `default: Date.utc_today()` in action arguments for sensible defaults that don't require client input.

4. **Validation before cross-domain create**: Validate prerequisites (e.g., item must have grocery_item_id) before attempting to create in another domain to give clear error messages.

### Files changed:
- `lib/grocery_planner/shopping/shopping_list.ex` - Added route for generate_from_meal_plans
- `lib/grocery_planner/meal_planning/meal_plan.ex` - Added route for complete
- `lib/grocery_planner/shopping/shopping_list_item.ex` - Added add_to_inventory action and route
- `test/grocery_planner_web/controllers/api/custom_actions_test.exs` - 10 behavioral tests

### Refactored to RESTful pattern (same day):
- Changed from RPC-style `PATCH /add_to_inventory` to RESTful `POST /grocery_items/:id/inventory_entries` with optional `shopping_list_item_id`
- This follows REST best practice: HTTP method indicates action (POST=create), URL indicates resource

### Additional learnings:
5. **RESTful vs RPC-style**: Avoid verb-based URLs like `/add_to_inventory`. Instead use standard resource creation with optional source parameters. Mobile clients benefit from predictable resource-oriented APIs.

6. **Cross-resource data derivation**: When creating a resource from another (InventoryEntry from ShoppingListItem), accept the source ID as an optional argument and derive values in a change module.

### Next priorities:
- US-008: Offline Sync Support

---

## 2026-02-03: US-005 - Consistent Error Responses Implementation

### What was implemented:
- Updated `ApiAuth` plug to return proper JSON:API v1.0 formatted 401 errors
- All error responses now follow JSON:API specification with required fields
- Comprehensive behavioral tests covering all error scenarios

### Key learnings:

1. **JSON:API error format requirements**: JSON:API v1.0 requires error objects to include `status` as a string, not an integer. The full structure should be:
   ```elixir
   %{
     errors: [%{id: "uuid", status: "401", code: "machine_code", title: "Title", detail: "Description"}],
     jsonapi: %{version: "1.0"}
   }
   ```

2. **Content-Type for JSON:API errors**: Error responses should use `application/vnd.api+json` content type, not just `application/json`.

3. **AshJsonApi error handling**: AshJsonApi automatically handles validation (400), authorization (403), and not found (404) errors with proper JSON:API formatting. Custom plugs (like auth) need manual formatting.

4. **Field-level validation errors**: AshJsonApi includes `source.pointer` in validation errors, pointing to the invalid field (e.g., `/data/attributes/name`).

5. **Tenant isolation error behavior**: Multitenancy with attribute-based isolation returns empty results (200 with `[]`) or 404 when accessing cross-tenant resources, not 403. This is expected behavior.

### Files changed:
- `lib/grocery_planner_web/plugs/api_auth.ex` - Updated 401 error response to JSON:API format
- `test/grocery_planner_web/controllers/api/error_responses_test.exs` - 10 behavioral tests for error responses

---

## 2026-02-03: US-008 - Offline Sync Support (Soft Deletes & Sync Actions)

### What was implemented:
- Added `deleted_at` column to all 11 syncable tables via migration
- Added indexes on `deleted_at` and `updated_at` for sync query performance
- Converted all 11 resources from hard delete to soft delete (`soft? true`)
- Added `:sync` read action to all 11 resources with `since` argument
- Added `filter expr(is_nil(deleted_at))` to all custom read actions
- Made `created_at` and `updated_at` timestamps public on all resources
- Added sync code_interface definitions to all 4 domain modules

### Resources modified (11 total):
- **Inventory**: GroceryItem, InventoryEntry
- **Shopping**: ShoppingList, ShoppingListItem
- **Recipes**: Recipe, RecipeIngredient
- **MealPlanning**: MealPlan, MealPlanTemplate, MealPlanTemplateEntry, MealPlanVoteSession, MealPlanVoteEntry

### Key learnings:

1. **Soft delete pattern in Ash**: Use `soft? true` on the destroy action with `change set_attribute(:deleted_at, &DateTime.utc_now/0)`. The primary read action must filter with `filter expr(is_nil(deleted_at))` and `primary_read_warning?: false` suppresses the warning about filtered primary reads.

2. **`defaults []` requires explicit primary actions**: When using `defaults []` (no auto-generated actions), you must add `primary? true` to both your custom `:read` and `:destroy` actions. Without this, Ash raises `NoPrimaryAction` errors.

3. **Custom read actions don't inherit primary read filters**: Each custom read action (e.g., `:favorites`, `:list_with_tags`, `:by_date_range`) needs its own `filter expr(is_nil(deleted_at))`. They do NOT inherit the filter from the primary `:read` action.

4. **Soft delete changes return value**: Soft delete returns `{:ok, record}` instead of `:ok`. All domain tests and LiveView handlers that matched on `:ok` needed updating to `{:ok, _}`.

5. **AshOban requires keyset pagination**: When a resource has AshOban triggers with `worker_read_action(:read)`, the read action must have `pagination keyset?: true, required?: false`. Without this, AshOban fails with "Limit is required" error.

6. **Sync action pattern**: The sync action uses a conditional filter that returns all records when `since` is nil, or only modified/deleted records after the timestamp. Results are sorted by `updated_at` ascending.

7. **MealPlanVoteEntry needed update_timestamp**: This resource only had `create_timestamp :created_at` - the `:sync` action requires `update_timestamp :updated_at` for tracking modifications.

### Files changed:
- `priv/repo/migrations/20260203230001_add_soft_deletes_for_sync.exs` - Migration for deleted_at columns and indexes
- All 11 resource files - Soft delete, sync actions, filtered custom reads, public timestamps
- `lib/grocery_planner/inventory.ex` - Added sync code interfaces
- `lib/grocery_planner/shopping.ex` - Added sync code interfaces
- `lib/grocery_planner/recipes.ex` - Added sync code interfaces
- `lib/grocery_planner/meal_planning.ex` - Added sync code interfaces
- 4 domain test files - Fixed `:ok` to `{:ok, _}` for soft delete returns
- 7 LiveView handler files - Fixed `:ok ->` to `{:ok, _} ->` for soft delete returns
- `test/grocery_planner/sync/offline_sync_test.exs` - 14 behavioral tests for sync

### Remaining US-008 items (future):
- Sync metadata (server timestamp, has_more flag) in responses
- Conflict detection via If-Unmodified-Since header support

### Next priorities:
- US-009: Bulk Operations for Sync Efficiency

---

## 2026-02-04: US-009 - Bulk Operations for Sync Efficiency

### What was implemented:
- Created `SyncController` with `POST /api/sync/batch` and `GET /api/sync/status` endpoints
- Supports all 11 syncable resource types: shopping_list, shopping_list_item, grocery_item, inventory_entry, recipe, recipe_ingredient, meal_plan, meal_plan_template, meal_plan_template_entry, vote_session, vote_entry
- Mixed create/update/delete operations in a single batch request
- Per-operation success/failure reporting
- Atomic mode (all-or-nothing) via `Repo.transaction` with rollback on first failure
- `temp_id` field for offline ID mapping (client sends temp ID, gets server ID back)
- `server_time` in every response for client sync coordination
- Added `get_vote_entry` code interface to MealPlanning domain

### Key learnings:

1. **Dynamic dispatch to domain code interfaces**: Using `apply(domain, :"create_#{resource}", args)` enables a generic batch handler without per-resource boilerplate. Map resource type strings to `{domain_module, resource_atom}` tuples for clean dispatch.

2. **Varying create signatures**: Most domain create functions follow `create_<resource>(account_id, attrs, opts)`, but some have extra positional args (e.g., `create_inventory_entry` needs `grocery_item_id`, `create_vote_entry_from_api` needs `vote_session_id`). Handle these as explicit pattern-matched clauses in the create dispatch.

3. **Atomic batch via Repo.transaction**: Wrapping `Enum.reduce_while` inside `Repo.transaction` with `Repo.rollback` on first error gives all-or-nothing semantics. Return 422 with partial results (including the error) so the client knows which operation failed.

4. **Ash notifications in transactions**: Ash warns about "missed notifications" when operations run inside a `Repo.transaction` without `return_notifications?: true`. This is expected behavior for batch operations and can be suppressed with `config :ash, :missed_notifications, :ignore` if needed.

5. **Custom controller alongside AshJsonApi**: Custom Phoenix controllers can coexist with `AshJsonApi.Router` by adding routes before the `forward("/json", JsonApiRouter)` in the router. The sync endpoints use regular JSON (not JSON:API format) since they're a custom protocol.

6. **Missing code interfaces**: Not all resources had complete CRUD code interfaces (e.g., `get_vote_entry` was missing from MealPlanning domain). Batch operations that need get+update or get+delete require a `get_by: [:id]` interface for every supported type.

7. **Resource-specific operation restrictions**: Some resources don't support all operations (e.g., vote_entry has no update action - votes are binary create/delete). The controller handles this with a `@no_update_types` list that returns a clear error for unsupported operations.

### Files changed:
- `lib/grocery_planner_web/controllers/api/sync_controller.ex` - New batch sync controller
- `lib/grocery_planner_web/router.ex` - Added sync routes under api_auth pipeline
- `lib/grocery_planner/meal_planning.ex` - Added `get_vote_entry` code interface
- `test/grocery_planner_web/controllers/api/sync_batch_test.exs` - 15 behavioral tests

### Next priorities:
- US-008 remaining: Sync metadata (server timestamp, has_more flag), conflict detection
